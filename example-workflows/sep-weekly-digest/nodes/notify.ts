import type { Context } from "tentacular";

interface Sep {
  number: number;
  sepId: string;
  title: string;
  state: string;
  author: string;
  createdAt: string;
  updatedAt: string;
  url: string;
  labels: string[];
  summary: string;
}

interface ActivityMetrics {
  highVelocity: Sep[];
  inactive: Sep[];
  newThisWeek: Sep[];
  closedThisWeek: Sep[];
  stateTransitions: { sepId: string; from: string; to: string }[];
  totalActive: number;
  totalInactive: number;
  velocityScore: number;
  weekOverWeek: { metric: string; thisWeek: number; lastWeek: number; delta: number }[];
}

interface PublishResult {
  uploaded: boolean;
  reportUrl: string;
}

interface NotifyOutput {
  delivered: boolean;
  status: number;
}

/** Send Slack notification with weekly digest summary */
export default async function run(ctx: Context, input: unknown): Promise<NotifyOutput> {
  const merged = input as { "publish-report": PublishResult; "analyze-activity": ActivityMetrics };
  const publish = merged["publish-report"];
  const metrics = merged["analyze-activity"];

  const slack = ctx.dependency("slack-webhook");
  if (!slack.secret) {
    ctx.log.warn("No slack webhook, skipping notification");
    return { delivered: false, status: 0 };
  }

  const blocks: Record<string, unknown>[] = [
    {
      type: "header",
      text: { type: "plain_text", text: "SEP Weekly Digest" },
    },
    {
      type: "section",
      text: {
        type: "mrkdwn",
        text: [
          `:bar_chart: *Health & Velocity*`,
          `Velocity Score: *${metrics.velocityScore}* | Active: *${metrics.totalActive}* | Inactive: *${metrics.totalInactive}*`,
        ].join("\n"),
      },
    },
    {
      type: "section",
      fields: [
        { type: "mrkdwn", text: `:rocket: *High Velocity*\n${metrics.highVelocity.length} SEPs` },
        { type: "mrkdwn", text: `:zzz: *Inactive*\n${metrics.inactive.length} SEPs` },
        { type: "mrkdwn", text: `:new: *New This Week*\n${metrics.newThisWeek.length} SEPs` },
        { type: "mrkdwn", text: `:checkered_flag: *Closed This Week*\n${metrics.closedThisWeek.length} SEPs` },
      ],
    },
  ];

  // Top high-velocity SEPs (up to 5)
  if (metrics.highVelocity.length > 0) {
    const lines = metrics.highVelocity.slice(0, 5).map(
      (sep) => `:rocket: <${sep.url}|${sep.sepId}>: ${sep.title} (${sep.state})`
    );
    if (metrics.highVelocity.length > 5) {
      lines.push(`_...and ${metrics.highVelocity.length - 5} more_`);
    }
    blocks.push({
      type: "section",
      text: { type: "mrkdwn", text: `*Most Active SEPs*\n${lines.join("\n")}` },
    });
  }

  // Report link button
  if (publish.uploaded && publish.reportUrl) {
    blocks.push({
      type: "actions",
      elements: [
        {
          type: "button",
          text: { type: "plain_text", text: "View Full Digest" },
          url: publish.reportUrl,
          style: "primary",
        },
      ],
    });
  }

  blocks.push(
    { type: "divider" },
    {
      type: "context",
      elements: [{ type: "mrkdwn", text: `Generated by Tentacular SEP Weekly Digest | ${new Date().toISOString()}` }],
    },
  );

  ctx.log.info("Sending Slack digest notification");

  // slack.secret is a full webhook URL (https://hooks.slack.com/services/...)
  // slack.fetch!() is scoped to the dependency host â€” pass path only
  const webhookUrl = new URL(slack.secret);
  const res = await slack.fetch!(webhookUrl.pathname, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ blocks }),
  });

  ctx.log.info(`Slack response: ${res.status}`);

  return { delivered: res.ok, status: res.status };
}
